"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["common"],{

/***/ 3023:
/*!*************************!*\
  !*** ./lib/supabase.ts ***!
  \*************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AccessKey: function() { return /* binding */ AccessKey; },\n/* harmony export */   AdminNotice: function() { return /* binding */ AdminNotice; },\n/* harmony export */   AndroidAppVersion: function() { return /* binding */ AndroidAppVersion; },\n/* harmony export */   AndroidBuildNumber: function() { return /* binding */ AndroidBuildNumber; },\n/* harmony export */   AndroidDeviceModel: function() { return /* binding */ AndroidDeviceModel; },\n/* harmony export */   AppVersion: function() { return /* binding */ AppVersion; },\n/* harmony export */   BaseEntity: function() { return /* binding */ BaseEntity; },\n/* harmony export */   BlacklistedUserAgent: function() { return /* binding */ BlacklistedUserAgent; },\n/* harmony export */   ChromeVersion: function() { return /* binding */ ChromeVersion; },\n/* harmony export */   Configuration: function() { return /* binding */ Configuration; },\n/* harmony export */   DeviceModel: function() { return /* binding */ DeviceModel; },\n/* harmony export */   GenerationHistory: function() { return /* binding */ GenerationHistory; },\n/* harmony export */   IOSVersion: function() { return /* binding */ IOSVersion; },\n/* harmony export */   InstagramDeviceModel: function() { return /* binding */ InstagramDeviceModel; },\n/* harmony export */   InstagramVersion: function() { return /* binding */ InstagramVersion; },\n/* harmony export */   ResolutionDpi: function() { return /* binding */ ResolutionDpi; },\n/* harmony export */   User: function() { return /* binding */ User; },\n/* harmony export */   UserGeneration: function() { return /* binding */ UserGeneration; },\n/* harmony export */   isSupabaseAvailable: function() { return /* binding */ isSupabaseAvailable; },\n/* harmony export */   supabase: function() { return /* binding */ supabase; }\n/* harmony export */ });\n/* harmony import */ var _supabase_supabase_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @supabase/supabase-js */ 1685);\n/* provided dependency */ var process = __webpack_require__(/*! process */ 7658);\n\nconst supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL || \"\";\nconst supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY || \"\";\n// Only create client if both URL and key are available\nconst supabase = supabaseUrl && supabaseAnonKey ? (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_0__.createClient)(supabaseUrl, supabaseAnonKey, {\n    auth: {\n        autoRefreshToken: true,\n        persistSession: true,\n        detectSessionInUrl: true\n    }\n}) : null;\nconst isSupabaseAvailable = ()=>{\n    return supabase !== null && supabaseUrl && supabaseAnonKey;\n};\n// Database entity classes\nclass BaseEntity {\n    static async list() {\n        let orderBy = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : \"id\";\n        if (!isSupabaseAvailable()) {\n            console.warn(\"Supabase not available for \".concat(this.tableName));\n            return [];\n        }\n        console.log(\"Fetching data from \".concat(this.tableName, \"...\"));\n        const { data, error } = await supabase.from(this.tableName).select(\"*\").order(orderBy.startsWith(\"-\") ? orderBy.slice(1) : orderBy, {\n            ascending: !orderBy.startsWith(\"-\")\n        });\n        console.log(\"\".concat(this.tableName, \" data:\"), data);\n        console.log(\"\".concat(this.tableName, \" error:\"), error);\n        if (error) {\n            console.error(\"Error fetching \".concat(this.tableName, \":\"), error);\n            throw error;\n        }\n        return data || [];\n    }\n    static async create(data) {\n        if (!isSupabaseAvailable()) {\n            throw new Error(\"Supabase not available\");\n        }\n        console.log(\"Creating \".concat(this.tableName, \":\"), data);\n        const { data: result, error } = await supabase.from(this.tableName).insert(data).select().single();\n        console.log(\"\".concat(this.tableName, \" create result:\"), result);\n        console.log(\"\".concat(this.tableName, \" create error:\"), error);\n        if (error) {\n            console.error(\"Error creating \".concat(this.tableName, \":\"), error);\n            throw error;\n        }\n        return result;\n    }\n    static async update(id, data) {\n        if (!isSupabaseAvailable()) {\n            throw new Error(\"Supabase not available\");\n        }\n        console.log(\"Updating \".concat(this.tableName, \" \").concat(id, \":\"), data);\n        const { data: result, error } = await supabase.from(this.tableName).update(data).eq(\"id\", id).select().single();\n        console.log(\"\".concat(this.tableName, \" update result:\"), result);\n        console.log(\"\".concat(this.tableName, \" update error:\"), error);\n        if (error) {\n            console.error(\"Error updating \".concat(this.tableName, \":\"), error);\n            throw error;\n        }\n        return result;\n    }\n    static async delete(id) {\n        if (!isSupabaseAvailable()) {\n            throw new Error(\"Supabase not available\");\n        }\n        console.log(\"Deleting \".concat(this.tableName, \" \").concat(id));\n        const { error } = await supabase.from(this.tableName).delete().eq(\"id\", id);\n        console.log(\"\".concat(this.tableName, \" delete error:\"), error);\n        if (error) {\n            console.error(\"Error deleting \".concat(this.tableName, \":\"), error);\n            throw error;\n        }\n        return true;\n    }\n    static async filter(filters) {\n        let orderBy = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"id\";\n        if (!isSupabaseAvailable()) {\n            console.warn(\"Supabase not available for \".concat(this.tableName));\n            return [];\n        }\n        console.log(\"Filtering \".concat(this.tableName, \":\"), filters);\n        let query = supabase.from(this.tableName).select(\"*\");\n        Object.entries(filters).forEach((param)=>{\n            let [key, value] = param;\n            query = query.eq(key, value);\n        });\n        const { data, error } = await query.order(orderBy.startsWith(\"-\") ? orderBy.slice(1) : orderBy, {\n            ascending: !orderBy.startsWith(\"-\")\n        });\n        console.log(\"\".concat(this.tableName, \" filter result:\"), data);\n        console.log(\"\".concat(this.tableName, \" filter error:\"), error);\n        if (error) {\n            console.error(\"Error filtering \".concat(this.tableName, \":\"), error);\n            throw error;\n        }\n        return data || [];\n    }\n}\nBaseEntity.tableName = \"\";\nclass DeviceModel extends BaseEntity {\n    static async list() {\n        let orderBy = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : \"-created_date\";\n        return super.list(orderBy);\n    }\n    static async filter(filters) {\n        let orderBy = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"-created_date\";\n        return super.filter(filters, orderBy);\n    }\n}\nDeviceModel.tableName = \"device_models\";\nclass IOSVersion extends BaseEntity {\n}\nIOSVersion.tableName = \"ios_versions\";\nclass AppVersion extends BaseEntity {\n}\nAppVersion.tableName = \"app_versions\";\nclass Configuration extends BaseEntity {\n}\nConfiguration.tableName = \"configurations\";\nclass GenerationHistory extends BaseEntity {\n}\nGenerationHistory.tableName = \"generation_history\";\nclass BlacklistedUserAgent extends BaseEntity {\n}\nBlacklistedUserAgent.tableName = \"blacklisted_user_agents\";\nclass AndroidDeviceModel extends BaseEntity {\n}\nAndroidDeviceModel.tableName = \"android_device_models\";\nclass AndroidBuildNumber extends BaseEntity {\n}\nAndroidBuildNumber.tableName = \"android_build_numbers\";\nclass AndroidAppVersion extends BaseEntity {\n}\nAndroidAppVersion.tableName = \"android_app_versions\";\n// Instagram-specific database entity classes\nclass InstagramDeviceModel extends BaseEntity {\n}\nInstagramDeviceModel.tableName = \"instagram_device_models\";\nclass InstagramVersion extends BaseEntity {\n}\nInstagramVersion.tableName = \"instagram_versions\";\nclass ChromeVersion extends BaseEntity {\n}\nChromeVersion.tableName = \"chrome_versions\";\nclass ResolutionDpi extends BaseEntity {\n}\nResolutionDpi.tableName = \"resolution_dpis\";\nclass User extends BaseEntity {\n    static async me() {\n        // Check if we're on the client side\n        if (false) {}\n        // Check localStorage\n        const storedUser = localStorage.getItem(\"current_user\");\n        if (storedUser) {\n            try {\n                return JSON.parse(storedUser);\n            } catch (e) {\n                localStorage.removeItem(\"current_user\");\n            }\n        }\n        throw new Error(\"Not authenticated\");\n    }\n    static async loginWithEmail(email) {\n        if (!isSupabaseAvailable()) {\n            throw new Error(\"Supabase not available\");\n        }\n        try {\n            console.log(\"Attempting admin login with email:\", email);\n            // First check if user exists\n            const { data: existingUser, error: selectError } = await supabase.from(\"users\").select(\"*\").eq(\"email\", email).single();\n            console.log(\"Existing user:\", existingUser);\n            console.log(\"Select error:\", selectError);\n            if (existingUser) {\n                // User exists, store in localStorage (only on client side)\n                if (true) {\n                    localStorage.setItem(\"current_user\", JSON.stringify(existingUser));\n                }\n                return existingUser;\n            }\n            // User doesn't exist, create new admin user\n            if (selectError && selectError.code === \"PGRST116\") {\n                const newUserData = {\n                    email: email,\n                    is_approved: true\n                };\n                console.log(\"Creating new admin user:\", newUserData);\n                const { data: newUser, error: insertError } = await supabase.from(\"users\").insert(newUserData).select().single();\n                console.log(\"New admin user created:\", newUser);\n                console.log(\"Insert error:\", insertError);\n                if (insertError) {\n                    console.error(\"Insert error:\", insertError);\n                    throw new Error(\"Failed to create user: \".concat(insertError.message));\n                }\n                // Store new user in localStorage (only on client side)\n                if (true) {\n                    localStorage.setItem(\"current_user\", JSON.stringify(newUser));\n                }\n                return newUser;\n            }\n            throw selectError;\n        } catch (error) {\n            console.error(\"Login error:\", error);\n            throw error;\n        }\n    }\n    static async login() {\n        if (false) {}\n        const email = prompt(\"Enter your email for testing:\");\n        if (email && email.trim()) {\n            try {\n                const user = await this.loginWithEmail(email.trim());\n                alert(\"Login successful! Welcome \".concat(user.email));\n                window.location.reload();\n            } catch (error) {\n                console.error(\"Login failed:\", error);\n                alert(\"Login failed: \" + error.message);\n            }\n        }\n    }\n    static async logout() {\n        if (true) {\n            localStorage.removeItem(\"current_user\");\n            window.location.reload();\n        }\n    }\n    // Check if user is logged in\n    static async getCurrentUser() {\n        if (false) {}\n        const storedUser = localStorage.getItem(\"current_user\");\n        if (storedUser) {\n            try {\n                return JSON.parse(storedUser);\n            } catch (e) {\n                localStorage.removeItem(\"current_user\");\n            }\n        }\n        return null;\n    }\n}\nUser.tableName = \"users\";\n// Helper function to get a random element from an array\nfunction getRandomElement(arr) {\n    return arr[Math.floor(Math.random() * arr.length)];\n}\n// Example usage of the updated generateUserAgent function\nasync function generateUserAgent() {\n    const deviceScaling = [\n        \"1.00\",\n        \"2.00\",\n        \"3.00\"\n    ];\n    const iosVersionUA = \"15.0\";\n    const iosVersion = {\n        webkit_version: \"605.1.15\",\n        build_number: \"19A5365\",\n        version: \"15.0\"\n    };\n    const appVersion = {\n        version: \"324.0\",\n        build_number: \"123456789\",\n        fbrv: null\n    };\n    const device = {\n        model_name: \"iPhone 12\"\n    };\n    const language = \"en_US\";\n    let userAgent = \"\";\n    if (Math.random() < 0.5) {\n        userAgent = \"Mozilla/5.0 (iPhone; CPU iPhone OS \".concat(iosVersionUA, \" like Mac OS X) AppleWebKit/\").concat(iosVersion.webkit_version, \" (KHTML, like Gecko) Mobile/\").concat(iosVersion.build_number, \" [FBAN/FBIOS;FBAV/\").concat(appVersion.version, \";FBBV/\").concat(appVersion.build_number, \";FBDV/\").concat(device.model_name, \";FBMD/iPhone;FBSN/iOS;FBSV/\").concat(iosVersion.version, \";FBSS/2;FBID/phone;FBLC/\").concat(language, \"]\");\n    } else {\n        const fbss = getRandomElement(deviceScaling.map((s)=>s.replace(\".00\", \"\")));\n        const extra = Math.random() < 0.1 ? \";FBOP/80\" : \"\";\n        // Use FBRV from database or generate random\n        let fbrv = appVersion.fbrv;\n        if (!fbrv) {\n            // Fallback to random generation if no FBRV in database\n            fbrv = Math.floor(Math.random() * 999999) + 700000000;\n        } else {\n            // Handle partial FBRV completion\n            const fbrvStr = fbrv.toString();\n            if (fbrvStr.length < 9) {\n                // Complete partial FBRV with random numbers\n                const remainingDigits = 9 - fbrvStr.length;\n                const randomPart = Math.floor(Math.random() * Math.pow(10, remainingDigits)).toString().padStart(remainingDigits, \"0\");\n                fbrv = fbrvStr + randomPart;\n            }\n        }\n        const fbrv_part = extra ? \"\" : \";FBOP/5;FBRV/\".concat(fbrv);\n        const iabmv = Math.random() < 0.9 ? \";IABMV/1\" : \"\";\n        userAgent = \"Mozilla/5.0 (iPhone; CPU iPhone OS \".concat(iosVersionUA, \" like Mac OS X) \") + \"AppleWebKit/\".concat(iosVersion.webkit_version, \" (KHTML, like Gecko) Mobile/\").concat(iosVersion.build_number, \" \") + \"[FBAN/FBIOS;FBAV/\".concat(appVersion.version, \";FBBV/\").concat(appVersion.build_number, \";FBDV/\").concat(device.model_name, \";FBMD/iPhone;FBSN/iOS;\") + \"FBSV/\".concat(iosVersion.version, \";FBSS/\").concat(fbss, \";FBID/phone;FBLC/\").concat(language).concat(extra).concat(fbrv_part).concat(iabmv, \"]\");\n    }\n    console.log(\"Generated User Agent:\", userAgent);\n    return userAgent;\n}\n// AccessKey entity class for authentication system\nclass AccessKey extends BaseEntity {\n    // Generate a random access key\n    static generateRandomKey() {\n        const chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";\n        let result = \"\";\n        for(let i = 0; i < 32; i++){\n            result += chars.charAt(Math.floor(Math.random() * chars.length));\n        }\n        return result;\n    }\n    // Create a new access key\n    static async createAccessKey(data) {\n        if (!isSupabaseAvailable()) {\n            throw new Error(\"Supabase not available\");\n        }\n        const keyData = {\n            access_key: data.access_key || this.generateRandomKey(),\n            user_name: data.user_name,\n            type: data.type,\n            expires_at: data.expires_at || null,\n            is_active: data.is_active !== undefined ? data.is_active : true,\n            created_at: new Date().toISOString(),\n            last_login: null\n        };\n        console.log(\"Creating access key:\", keyData);\n        const { data: result, error } = await supabase.from(this.tableName).insert(keyData).select().single();\n        if (error) {\n            console.error(\"Error creating access key:\", error);\n            throw error;\n        }\n        return result;\n    }\n    // Update access key (admin can modify keys)\n    static async updateAccessKey(id, data) {\n        return this.update(id, data);\n    }\n    // Delete access key\n    static async deleteAccessKey(id) {\n        return this.delete(id);\n    }\n    // List all access keys (admin only)\n    static async listAllKeys() {\n        return this.list(\"-created_at\");\n    }\n    static async authenticate(accessKey) {\n        if (!isSupabaseAvailable()) {\n            throw new Error(\"Supabase not available\");\n        }\n        console.log(\"Authenticating with key:\", accessKey);\n        const { data: user, error } = await supabase.from(this.tableName).select(\"*\").eq(\"access_key\", accessKey).single();\n        if (error || !user) {\n            console.error(\"Authentication failed:\", error);\n            throw new Error(\"Invalid access key\");\n        }\n        // Check if key is active\n        if (!user.is_active) {\n            throw new Error(\"Access key is deactivated\");\n        }\n        // Check if key is expired\n        if (user.expires_at) {\n            const expiryDate = new Date(user.expires_at);\n            const now = new Date();\n            if (now > expiryDate) {\n                throw new Error(\"Access key has expired\");\n            }\n        }\n        // Update last login\n        await this.update(user.id, {\n            last_login: new Date().toISOString()\n        });\n        console.log(\"Authentication successful:\", user);\n        return user;\n    }\n    // Get current authenticated user from localStorage with sessionStorage fallback\n    static getCurrentUser() {\n        if (false) {}\n        // Try localStorage first\n        let storedUser = localStorage.getItem(\"authenticated_user\");\n        let storageType = \"localStorage\";\n        // If localStorage fails or is empty, try sessionStorage\n        if (!storedUser) {\n            storedUser = sessionStorage.getItem(\"authenticated_user\");\n            storageType = \"sessionStorage\";\n        }\n        if (storedUser) {\n            try {\n                const user = JSON.parse(storedUser);\n                console.log(\"Retrieved user from \".concat(storageType, \":\"), user);\n                return user;\n            } catch (e) {\n                console.log(\"Failed to parse user from \".concat(storageType, \", removing:\"), e);\n                // Clean up corrupted data from both storages\n                localStorage.removeItem(\"authenticated_user\");\n                sessionStorage.removeItem(\"authenticated_user\");\n            }\n        }\n        console.log(\"No user found in either localStorage or sessionStorage\");\n        return null;\n    }\n    static async validateCurrentUser() {\n        const currentUser = this.getCurrentUser();\n        if (!currentUser) return null;\n        try {\n            // Re-authenticate with database to get fresh data\n            const validatedUser = await this.authenticate(currentUser.access_key);\n            this.setCurrentUser(validatedUser);\n            return validatedUser;\n        } catch (error) {\n            // Key is invalid, deleted, or expired\n            this.logout();\n            return null;\n        }\n    }\n    // Store authenticated user\n    static setCurrentUser(user) {\n        if (true) {\n            localStorage.setItem(\"authenticated_user\", JSON.stringify(user));\n        }\n    }\n    // Logout user\n    static logout() {\n        if (true) {\n            localStorage.removeItem(\"authenticated_user\");\n            sessionStorage.removeItem(\"authenticated_user\");\n            window.location.href = \"/login\";\n        }\n    }\n    static isAdmin(user) {\n        const currentUser = user || this.getCurrentUser();\n        return (currentUser === null || currentUser === void 0 ? void 0 : currentUser.type) === \"admin\" // Only admin type users are admins\n        ;\n    }\n    static canGenerate(user) {\n        const currentUser = user || this.getCurrentUser();\n        return (currentUser === null || currentUser === void 0 ? void 0 : currentUser.type) === \"user\" || (currentUser === null || currentUser === void 0 ? void 0 : currentUser.type) === \"admin\" // Both user and admin can generate\n        ;\n    }\n    static isUser(user) {\n        const currentUser = user || this.getCurrentUser();\n        return (currentUser === null || currentUser === void 0 ? void 0 : currentUser.type) === \"user\";\n    }\n}\nAccessKey.tableName = \"access_keys\";\nclass UserGeneration extends BaseEntity {\n    static async createGeneration(accessKey, userName, generatedData, platform) {\n        if (!isSupabaseAvailable()) {\n            throw new Error(\"Supabase not available\");\n        }\n        const generationData = {\n            access_key: accessKey,\n            user_name: userName,\n            generated_data: generatedData,\n            platform: platform,\n            created_at: new Date().toISOString()\n        };\n        return await this.create(generationData);\n    }\n    static async getUserHistory(accessKey) {\n        let limit = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 50;\n        if (!isSupabaseAvailable()) {\n            return [];\n        }\n        const { data, error } = await supabase.from(this.tableName).select(\"*\").eq(\"access_key\", accessKey).order(\"created_at\", {\n            ascending: false\n        }).limit(limit);\n        if (error) {\n            console.error(\"Error fetching user history:\", error);\n            return [];\n        }\n        return data || [];\n    }\n}\nUserGeneration.tableName = \"user_generations\";\nclass AdminNotice extends BaseEntity {\n    static async getActiveNotices(targetUser) {\n        if (!isSupabaseAvailable()) {\n            return [];\n        }\n        let query = supabase.from(this.tableName).select(\"*\").eq(\"is_active\", true);\n        // Get notices for specific user or global notices\n        if (targetUser) {\n            query = query.or(\"target_user.eq.\".concat(targetUser, \",target_user.is.null\"));\n        } else {\n            query = query.is(\"target_user\", null);\n        }\n        // Filter out expired notices\n        query = query.or(\"expires_at.is.null,expires_at.gt.\".concat(new Date().toISOString()));\n        const { data, error } = await query.order(\"created_at\", {\n            ascending: false\n        });\n        if (error) {\n            console.error(\"Error fetching notices:\", error);\n            return [];\n        }\n        return data || [];\n    }\n    static async createNotice(title, message, targetUser, expiresAt) {\n        const noticeData = {\n            title,\n            message,\n            target_user: targetUser || null,\n            expires_at: expiresAt || null,\n            is_active: true,\n            created_at: new Date().toISOString()\n        };\n        return await this.create(noticeData);\n    }\n}\nAdminNotice.tableName = \"admin_notices\";\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUVBLE9BQU8sTUFBTSxJQUFJLENBQUM1RyxNQUFNLENBQUNnSjtJQUMzQjtBQUNGO0FBMUNhUixZQUNKbEosWUFBWSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9saWIvc3VwYWJhc2UudHM/Yzk5ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjcmVhdGVDbGllbnQgfSBmcm9tIFwiQHN1cGFiYXNlL3N1cGFiYXNlLWpzXCJcblxuY29uc3Qgc3VwYWJhc2VVcmwgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19TVVBBQkFTRV9VUkwgfHwgXCJcIlxuY29uc3Qgc3VwYWJhc2VBbm9uS2V5ID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfU1VQQUJBU0VfQU5PTl9LRVkgfHwgXCJcIlxuXG4vLyBPbmx5IGNyZWF0ZSBjbGllbnQgaWYgYm90aCBVUkwgYW5kIGtleSBhcmUgYXZhaWxhYmxlXG5leHBvcnQgY29uc3Qgc3VwYWJhc2UgPVxuICBzdXBhYmFzZVVybCAmJiBzdXBhYmFzZUFub25LZXlcbiAgICA/IGNyZWF0ZUNsaWVudChzdXBhYmFzZVVybCwgc3VwYWJhc2VBbm9uS2V5LCB7XG4gICAgICAgIGF1dGg6IHtcbiAgICAgICAgICBhdXRvUmVmcmVzaFRva2VuOiB0cnVlLFxuICAgICAgICAgIHBlcnNpc3RTZXNzaW9uOiB0cnVlLFxuICAgICAgICAgIGRldGVjdFNlc3Npb25JblVybDogdHJ1ZSxcbiAgICAgICAgfSxcbiAgICAgIH0pXG4gICAgOiBudWxsXG5cbmV4cG9ydCBjb25zdCBpc1N1cGFiYXNlQXZhaWxhYmxlID0gKCkgPT4ge1xuICByZXR1cm4gc3VwYWJhc2UgIT09IG51bGwgJiYgc3VwYWJhc2VVcmwgJiYgc3VwYWJhc2VBbm9uS2V5XG59XG5cbi8vIERhdGFiYXNlIGVudGl0eSBjbGFzc2VzXG5leHBvcnQgY2xhc3MgQmFzZUVudGl0eSB7XG4gIHN0YXRpYyB0YWJsZU5hbWUgPSBcIlwiXG5cbiAgc3RhdGljIGFzeW5jIGxpc3Qob3JkZXJCeSA9IFwiaWRcIikge1xuICAgIGlmICghaXNTdXBhYmFzZUF2YWlsYWJsZSgpKSB7XG4gICAgICBjb25zb2xlLndhcm4oYFN1cGFiYXNlIG5vdCBhdmFpbGFibGUgZm9yICR7dGhpcy50YWJsZU5hbWV9YClcbiAgICAgIHJldHVybiBbXVxuICAgIH1cblxuICAgIGNvbnNvbGUubG9nKGBGZXRjaGluZyBkYXRhIGZyb20gJHt0aGlzLnRhYmxlTmFtZX0uLi5gKVxuXG4gICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2UhXG4gICAgICAuZnJvbSh0aGlzLnRhYmxlTmFtZSlcbiAgICAgIC5zZWxlY3QoXCIqXCIpXG4gICAgICAub3JkZXIob3JkZXJCeS5zdGFydHNXaXRoKFwiLVwiKSA/IG9yZGVyQnkuc2xpY2UoMSkgOiBvcmRlckJ5LCB7XG4gICAgICAgIGFzY2VuZGluZzogIW9yZGVyQnkuc3RhcnRzV2l0aChcIi1cIiksXG4gICAgICB9KVxuXG4gICAgY29uc29sZS5sb2coYCR7dGhpcy50YWJsZU5hbWV9IGRhdGE6YCwgZGF0YSlcbiAgICBjb25zb2xlLmxvZyhgJHt0aGlzLnRhYmxlTmFtZX0gZXJyb3I6YCwgZXJyb3IpXG5cbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGZldGNoaW5nICR7dGhpcy50YWJsZU5hbWV9OmAsIGVycm9yKVxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gICAgcmV0dXJuIGRhdGEgfHwgW11cbiAgfVxuXG4gIHN0YXRpYyBhc3luYyBjcmVhdGUoZGF0YTogYW55KSB7XG4gICAgaWYgKCFpc1N1cGFiYXNlQXZhaWxhYmxlKCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlN1cGFiYXNlIG5vdCBhdmFpbGFibGVcIilcbiAgICB9XG5cbiAgICBjb25zb2xlLmxvZyhgQ3JlYXRpbmcgJHt0aGlzLnRhYmxlTmFtZX06YCwgZGF0YSlcblxuICAgIGNvbnN0IHsgZGF0YTogcmVzdWx0LCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2UhLmZyb20odGhpcy50YWJsZU5hbWUpLmluc2VydChkYXRhKS5zZWxlY3QoKS5zaW5nbGUoKVxuXG4gICAgY29uc29sZS5sb2coYCR7dGhpcy50YWJsZU5hbWV9IGNyZWF0ZSByZXN1bHQ6YCwgcmVzdWx0KVxuICAgIGNvbnNvbGUubG9nKGAke3RoaXMudGFibGVOYW1lfSBjcmVhdGUgZXJyb3I6YCwgZXJyb3IpXG5cbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGNyZWF0aW5nICR7dGhpcy50YWJsZU5hbWV9OmAsIGVycm9yKVxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG5cbiAgc3RhdGljIGFzeW5jIHVwZGF0ZShpZDogc3RyaW5nLCBkYXRhOiBhbnkpIHtcbiAgICBpZiAoIWlzU3VwYWJhc2VBdmFpbGFibGUoKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU3VwYWJhc2Ugbm90IGF2YWlsYWJsZVwiKVxuICAgIH1cblxuICAgIGNvbnNvbGUubG9nKGBVcGRhdGluZyAke3RoaXMudGFibGVOYW1lfSAke2lkfTpgLCBkYXRhKVxuXG4gICAgY29uc3QgeyBkYXRhOiByZXN1bHQsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZSEuZnJvbSh0aGlzLnRhYmxlTmFtZSkudXBkYXRlKGRhdGEpLmVxKFwiaWRcIiwgaWQpLnNlbGVjdCgpLnNpbmdsZSgpXG5cbiAgICBjb25zb2xlLmxvZyhgJHt0aGlzLnRhYmxlTmFtZX0gdXBkYXRlIHJlc3VsdDpgLCByZXN1bHQpXG4gICAgY29uc29sZS5sb2coYCR7dGhpcy50YWJsZU5hbWV9IHVwZGF0ZSBlcnJvcjpgLCBlcnJvcilcblxuICAgIGlmIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgdXBkYXRpbmcgJHt0aGlzLnRhYmxlTmFtZX06YCwgZXJyb3IpXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cblxuICBzdGF0aWMgYXN5bmMgZGVsZXRlKGlkOiBzdHJpbmcpIHtcbiAgICBpZiAoIWlzU3VwYWJhc2VBdmFpbGFibGUoKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU3VwYWJhc2Ugbm90IGF2YWlsYWJsZVwiKVxuICAgIH1cblxuICAgIGNvbnNvbGUubG9nKGBEZWxldGluZyAke3RoaXMudGFibGVOYW1lfSAke2lkfWApXG5cbiAgICBjb25zdCB7IGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZSEuZnJvbSh0aGlzLnRhYmxlTmFtZSkuZGVsZXRlKCkuZXEoXCJpZFwiLCBpZClcblxuICAgIGNvbnNvbGUubG9nKGAke3RoaXMudGFibGVOYW1lfSBkZWxldGUgZXJyb3I6YCwgZXJyb3IpXG5cbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGRlbGV0aW5nICR7dGhpcy50YWJsZU5hbWV9OmAsIGVycm9yKVxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIHN0YXRpYyBhc3luYyBmaWx0ZXIoZmlsdGVyczogYW55LCBvcmRlckJ5ID0gXCJpZFwiKSB7XG4gICAgaWYgKCFpc1N1cGFiYXNlQXZhaWxhYmxlKCkpIHtcbiAgICAgIGNvbnNvbGUud2FybihgU3VwYWJhc2Ugbm90IGF2YWlsYWJsZSBmb3IgJHt0aGlzLnRhYmxlTmFtZX1gKVxuICAgICAgcmV0dXJuIFtdXG4gICAgfVxuXG4gICAgY29uc29sZS5sb2coYEZpbHRlcmluZyAke3RoaXMudGFibGVOYW1lfTpgLCBmaWx0ZXJzKVxuXG4gICAgbGV0IHF1ZXJ5ID0gc3VwYWJhc2UhLmZyb20odGhpcy50YWJsZU5hbWUpLnNlbGVjdChcIipcIilcblxuICAgIE9iamVjdC5lbnRyaWVzKGZpbHRlcnMpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgcXVlcnkgPSBxdWVyeS5lcShrZXksIHZhbHVlKVxuICAgIH0pXG5cbiAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBxdWVyeS5vcmRlcihvcmRlckJ5LnN0YXJ0c1dpdGgoXCItXCIpID8gb3JkZXJCeS5zbGljZSgxKSA6IG9yZGVyQnksIHtcbiAgICAgIGFzY2VuZGluZzogIW9yZGVyQnkuc3RhcnRzV2l0aChcIi1cIiksXG4gICAgfSlcblxuICAgIGNvbnNvbGUubG9nKGAke3RoaXMudGFibGVOYW1lfSBmaWx0ZXIgcmVzdWx0OmAsIGRhdGEpXG4gICAgY29uc29sZS5sb2coYCR7dGhpcy50YWJsZU5hbWV9IGZpbHRlciBlcnJvcjpgLCBlcnJvcilcblxuICAgIGlmIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgZmlsdGVyaW5nICR7dGhpcy50YWJsZU5hbWV9OmAsIGVycm9yKVxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gICAgcmV0dXJuIGRhdGEgfHwgW11cbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgRGV2aWNlTW9kZWwgZXh0ZW5kcyBCYXNlRW50aXR5IHtcbiAgc3RhdGljIHRhYmxlTmFtZSA9IFwiZGV2aWNlX21vZGVsc1wiXG5cbiAgc3RhdGljIGFzeW5jIGxpc3Qob3JkZXJCeSA9IFwiLWNyZWF0ZWRfZGF0ZVwiKSB7XG4gICAgcmV0dXJuIHN1cGVyLmxpc3Qob3JkZXJCeSlcbiAgfVxuXG4gIHN0YXRpYyBhc3luYyBmaWx0ZXIoZmlsdGVyczogYW55LCBvcmRlckJ5ID0gXCItY3JlYXRlZF9kYXRlXCIpIHtcbiAgICByZXR1cm4gc3VwZXIuZmlsdGVyKGZpbHRlcnMsIG9yZGVyQnkpXG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIElPU1ZlcnNpb24gZXh0ZW5kcyBCYXNlRW50aXR5IHtcbiAgc3RhdGljIHRhYmxlTmFtZSA9IFwiaW9zX3ZlcnNpb25zXCJcbn1cblxuZXhwb3J0IGNsYXNzIEFwcFZlcnNpb24gZXh0ZW5kcyBCYXNlRW50aXR5IHtcbiAgc3RhdGljIHRhYmxlTmFtZSA9IFwiYXBwX3ZlcnNpb25zXCJcbn1cblxuZXhwb3J0IGNsYXNzIENvbmZpZ3VyYXRpb24gZXh0ZW5kcyBCYXNlRW50aXR5IHtcbiAgc3RhdGljIHRhYmxlTmFtZSA9IFwiY29uZmlndXJhdGlvbnNcIlxufVxuXG5leHBvcnQgY2xhc3MgR2VuZXJhdGlvbkhpc3RvcnkgZXh0ZW5kcyBCYXNlRW50aXR5IHtcbiAgc3RhdGljIHRhYmxlTmFtZSA9IFwiZ2VuZXJhdGlvbl9oaXN0b3J5XCJcbn1cblxuZXhwb3J0IGNsYXNzIEJsYWNrbGlzdGVkVXNlckFnZW50IGV4dGVuZHMgQmFzZUVudGl0eSB7XG4gIHN0YXRpYyB0YWJsZU5hbWUgPSBcImJsYWNrbGlzdGVkX3VzZXJfYWdlbnRzXCJcbn1cblxuZXhwb3J0IGNsYXNzIEFuZHJvaWREZXZpY2VNb2RlbCBleHRlbmRzIEJhc2VFbnRpdHkge1xuICBzdGF0aWMgdGFibGVOYW1lID0gXCJhbmRyb2lkX2RldmljZV9tb2RlbHNcIlxufVxuXG5leHBvcnQgY2xhc3MgQW5kcm9pZEJ1aWxkTnVtYmVyIGV4dGVuZHMgQmFzZUVudGl0eSB7XG4gIHN0YXRpYyB0YWJsZU5hbWUgPSBcImFuZHJvaWRfYnVpbGRfbnVtYmVyc1wiXG59XG5cbmV4cG9ydCBjbGFzcyBBbmRyb2lkQXBwVmVyc2lvbiBleHRlbmRzIEJhc2VFbnRpdHkge1xuICBzdGF0aWMgdGFibGVOYW1lID0gXCJhbmRyb2lkX2FwcF92ZXJzaW9uc1wiXG59XG5cbi8vIEluc3RhZ3JhbS1zcGVjaWZpYyBkYXRhYmFzZSBlbnRpdHkgY2xhc3Nlc1xuZXhwb3J0IGNsYXNzIEluc3RhZ3JhbURldmljZU1vZGVsIGV4dGVuZHMgQmFzZUVudGl0eSB7XG4gIHN0YXRpYyB0YWJsZU5hbWUgPSBcImluc3RhZ3JhbV9kZXZpY2VfbW9kZWxzXCJcbn1cblxuZXhwb3J0IGNsYXNzIEluc3RhZ3JhbVZlcnNpb24gZXh0ZW5kcyBCYXNlRW50aXR5IHtcbiAgc3RhdGljIHRhYmxlTmFtZSA9IFwiaW5zdGFncmFtX3ZlcnNpb25zXCJcbn1cblxuZXhwb3J0IGNsYXNzIENocm9tZVZlcnNpb24gZXh0ZW5kcyBCYXNlRW50aXR5IHtcbiAgc3RhdGljIHRhYmxlTmFtZSA9IFwiY2hyb21lX3ZlcnNpb25zXCJcbn1cblxuZXhwb3J0IGNsYXNzIFJlc29sdXRpb25EcGkgZXh0ZW5kcyBCYXNlRW50aXR5IHtcbiAgc3RhdGljIHRhYmxlTmFtZSA9IFwicmVzb2x1dGlvbl9kcGlzXCJcbn1cblxuZXhwb3J0IGNsYXNzIFVzZXIgZXh0ZW5kcyBCYXNlRW50aXR5IHtcbiAgc3RhdGljIHRhYmxlTmFtZSA9IFwidXNlcnNcIlxuXG4gIHN0YXRpYyBhc3luYyBtZSgpIHtcbiAgICAvLyBDaGVjayBpZiB3ZSdyZSBvbiB0aGUgY2xpZW50IHNpZGVcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IGF1dGhlbnRpY2F0ZWRcIilcbiAgICB9XG5cbiAgICAvLyBDaGVjayBsb2NhbFN0b3JhZ2VcbiAgICBjb25zdCBzdG9yZWRVc2VyID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oXCJjdXJyZW50X3VzZXJcIilcbiAgICBpZiAoc3RvcmVkVXNlcikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2Uoc3RvcmVkVXNlcilcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oXCJjdXJyZW50X3VzZXJcIilcbiAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IGF1dGhlbnRpY2F0ZWRcIilcbiAgfVxuXG4gIHN0YXRpYyBhc3luYyBsb2dpbldpdGhFbWFpbChlbWFpbDogc3RyaW5nKSB7XG4gICAgaWYgKCFpc1N1cGFiYXNlQXZhaWxhYmxlKCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlN1cGFiYXNlIG5vdCBhdmFpbGFibGVcIilcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgY29uc29sZS5sb2coXCJBdHRlbXB0aW5nIGFkbWluIGxvZ2luIHdpdGggZW1haWw6XCIsIGVtYWlsKVxuXG4gICAgICAvLyBGaXJzdCBjaGVjayBpZiB1c2VyIGV4aXN0c1xuICAgICAgY29uc3QgeyBkYXRhOiBleGlzdGluZ1VzZXIsIGVycm9yOiBzZWxlY3RFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2UhXG4gICAgICAgIC5mcm9tKFwidXNlcnNcIilcbiAgICAgICAgLnNlbGVjdChcIipcIilcbiAgICAgICAgLmVxKFwiZW1haWxcIiwgZW1haWwpXG4gICAgICAgIC5zaW5nbGUoKVxuXG4gICAgICBjb25zb2xlLmxvZyhcIkV4aXN0aW5nIHVzZXI6XCIsIGV4aXN0aW5nVXNlcilcbiAgICAgIGNvbnNvbGUubG9nKFwiU2VsZWN0IGVycm9yOlwiLCBzZWxlY3RFcnJvcilcblxuICAgICAgaWYgKGV4aXN0aW5nVXNlcikge1xuICAgICAgICAvLyBVc2VyIGV4aXN0cywgc3RvcmUgaW4gbG9jYWxTdG9yYWdlIChvbmx5IG9uIGNsaWVudCBzaWRlKVxuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKFwiY3VycmVudF91c2VyXCIsIEpTT04uc3RyaW5naWZ5KGV4aXN0aW5nVXNlcikpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGV4aXN0aW5nVXNlclxuICAgICAgfVxuXG4gICAgICAvLyBVc2VyIGRvZXNuJ3QgZXhpc3QsIGNyZWF0ZSBuZXcgYWRtaW4gdXNlclxuICAgICAgaWYgKHNlbGVjdEVycm9yICYmIHNlbGVjdEVycm9yLmNvZGUgPT09IFwiUEdSU1QxMTZcIikge1xuICAgICAgICBjb25zdCBuZXdVc2VyRGF0YSA9IHtcbiAgICAgICAgICBlbWFpbDogZW1haWwsXG4gICAgICAgICAgaXNfYXBwcm92ZWQ6IHRydWUsIC8vIEFsbCB1c2VycyBhcmUgYWRtaW4gYW5kIGFwcHJvdmVkXG4gICAgICAgIH1cblxuICAgICAgICBjb25zb2xlLmxvZyhcIkNyZWF0aW5nIG5ldyBhZG1pbiB1c2VyOlwiLCBuZXdVc2VyRGF0YSlcblxuICAgICAgICBjb25zdCB7IGRhdGE6IG5ld1VzZXIsIGVycm9yOiBpbnNlcnRFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2UhXG4gICAgICAgICAgLmZyb20oXCJ1c2Vyc1wiKVxuICAgICAgICAgIC5pbnNlcnQobmV3VXNlckRhdGEpXG4gICAgICAgICAgLnNlbGVjdCgpXG4gICAgICAgICAgLnNpbmdsZSgpXG5cbiAgICAgICAgY29uc29sZS5sb2coXCJOZXcgYWRtaW4gdXNlciBjcmVhdGVkOlwiLCBuZXdVc2VyKVxuICAgICAgICBjb25zb2xlLmxvZyhcIkluc2VydCBlcnJvcjpcIiwgaW5zZXJ0RXJyb3IpXG5cbiAgICAgICAgaWYgKGluc2VydEVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcIkluc2VydCBlcnJvcjpcIiwgaW5zZXJ0RXJyb3IpXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gY3JlYXRlIHVzZXI6ICR7aW5zZXJ0RXJyb3IubWVzc2FnZX1gKVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gU3RvcmUgbmV3IHVzZXIgaW4gbG9jYWxTdG9yYWdlIChvbmx5IG9uIGNsaWVudCBzaWRlKVxuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKFwiY3VycmVudF91c2VyXCIsIEpTT04uc3RyaW5naWZ5KG5ld1VzZXIpKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdVc2VyXG4gICAgICB9XG5cbiAgICAgIHRocm93IHNlbGVjdEVycm9yXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJMb2dpbiBlcnJvcjpcIiwgZXJyb3IpXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBhc3luYyBsb2dpbigpIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuXG5cbiAgICBjb25zdCBlbWFpbCA9IHByb21wdChcIkVudGVyIHlvdXIgZW1haWwgZm9yIHRlc3Rpbmc6XCIpXG4gICAgaWYgKGVtYWlsICYmIGVtYWlsLnRyaW0oKSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgdXNlciA9IGF3YWl0IHRoaXMubG9naW5XaXRoRW1haWwoZW1haWwudHJpbSgpKVxuICAgICAgICBhbGVydChgTG9naW4gc3VjY2Vzc2Z1bCEgV2VsY29tZSAke3VzZXIuZW1haWx9YClcbiAgICAgICAgd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiTG9naW4gZmFpbGVkOlwiLCBlcnJvcilcbiAgICAgICAgYWxlcnQoXCJMb2dpbiBmYWlsZWQ6IFwiICsgZXJyb3IubWVzc2FnZSlcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBzdGF0aWMgYXN5bmMgbG9nb3V0KCkge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShcImN1cnJlbnRfdXNlclwiKVxuICAgICAgd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpXG4gICAgfVxuICB9XG5cbiAgLy8gQ2hlY2sgaWYgdXNlciBpcyBsb2dnZWQgaW5cbiAgc3RhdGljIGFzeW5jIGdldEN1cnJlbnRVc2VyKCkge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cblxuICAgIGNvbnN0IHN0b3JlZFVzZXIgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShcImN1cnJlbnRfdXNlclwiKVxuICAgIGlmIChzdG9yZWRVc2VyKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShzdG9yZWRVc2VyKVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShcImN1cnJlbnRfdXNlclwiKVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbFxuICB9XG59XG5cbi8vIEhlbHBlciBmdW5jdGlvbiB0byBnZXQgYSByYW5kb20gZWxlbWVudCBmcm9tIGFuIGFycmF5XG5mdW5jdGlvbiBnZXRSYW5kb21FbGVtZW50KGFycjogYW55W10pIHtcbiAgcmV0dXJuIGFycltNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBhcnIubGVuZ3RoKV1cbn1cblxuLy8gRXhhbXBsZSB1c2FnZSBvZiB0aGUgdXBkYXRlZCBnZW5lcmF0ZVVzZXJBZ2VudCBmdW5jdGlvblxuYXN5bmMgZnVuY3Rpb24gZ2VuZXJhdGVVc2VyQWdlbnQoKSB7XG4gIGNvbnN0IGRldmljZVNjYWxpbmcgPSBbXCIxLjAwXCIsIFwiMi4wMFwiLCBcIjMuMDBcIl1cbiAgY29uc3QgaW9zVmVyc2lvblVBID0gXCIxNS4wXCJcbiAgY29uc3QgaW9zVmVyc2lvbiA9IHtcbiAgICB3ZWJraXRfdmVyc2lvbjogXCI2MDUuMS4xNVwiLFxuICAgIGJ1aWxkX251bWJlcjogXCIxOUE1MzY1XCIsXG4gICAgdmVyc2lvbjogXCIxNS4wXCIsXG4gIH1cbiAgY29uc3QgYXBwVmVyc2lvbiA9IHtcbiAgICB2ZXJzaW9uOiBcIjMyNC4wXCIsXG4gICAgYnVpbGRfbnVtYmVyOiBcIjEyMzQ1Njc4OVwiLFxuICAgIGZicnY6IG51bGwsIC8vIFRoaXMgc2hvdWxkIGJlIGZldGNoZWQgZnJvbSB0aGUgZGF0YWJhc2VcbiAgfVxuICBjb25zdCBkZXZpY2UgPSB7XG4gICAgbW9kZWxfbmFtZTogXCJpUGhvbmUgMTJcIixcbiAgfVxuICBjb25zdCBsYW5ndWFnZSA9IFwiZW5fVVNcIlxuXG4gIGxldCB1c2VyQWdlbnQgPSBcIlwiXG5cbiAgaWYgKE1hdGgucmFuZG9tKCkgPCAwLjUpIHtcbiAgICB1c2VyQWdlbnQgPSBgTW96aWxsYS81LjAgKGlQaG9uZTsgQ1BVIGlQaG9uZSBPUyAke2lvc1ZlcnNpb25VQX0gbGlrZSBNYWMgT1MgWCkgQXBwbGVXZWJLaXQvJHtpb3NWZXJzaW9uLndlYmtpdF92ZXJzaW9ufSAoS0hUTUwsIGxpa2UgR2Vja28pIE1vYmlsZS8ke2lvc1ZlcnNpb24uYnVpbGRfbnVtYmVyfSBbRkJBTi9GQklPUztGQkFWLyR7YXBwVmVyc2lvbi52ZXJzaW9ufTtGQkJWLyR7YXBwVmVyc2lvbi5idWlsZF9udW1iZXJ9O0ZCRFYvJHtkZXZpY2UubW9kZWxfbmFtZX07RkJNRC9pUGhvbmU7RkJTTi9pT1M7RkJTVi8ke2lvc1ZlcnNpb24udmVyc2lvbn07RkJTUy8yO0ZCSUQvcGhvbmU7RkJMQy8ke2xhbmd1YWdlfV1gXG4gIH0gZWxzZSB7XG4gICAgY29uc3QgZmJzcyA9IGdldFJhbmRvbUVsZW1lbnQoZGV2aWNlU2NhbGluZy5tYXAoKHMpID0+IHMucmVwbGFjZShcIi4wMFwiLCBcIlwiKSkpXG4gICAgY29uc3QgZXh0cmEgPSBNYXRoLnJhbmRvbSgpIDwgMC4xID8gXCI7RkJPUC84MFwiIDogXCJcIlxuXG4gICAgLy8gVXNlIEZCUlYgZnJvbSBkYXRhYmFzZSBvciBnZW5lcmF0ZSByYW5kb21cbiAgICBsZXQgZmJydiA9IGFwcFZlcnNpb24uZmJydlxuICAgIGlmICghZmJydikge1xuICAgICAgLy8gRmFsbGJhY2sgdG8gcmFuZG9tIGdlbmVyYXRpb24gaWYgbm8gRkJSViBpbiBkYXRhYmFzZVxuICAgICAgZmJydiA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDk5OTk5OSkgKyA3MDAwMDAwMDBcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSGFuZGxlIHBhcnRpYWwgRkJSViBjb21wbGV0aW9uXG4gICAgICBjb25zdCBmYnJ2U3RyID0gZmJydi50b1N0cmluZygpXG4gICAgICBpZiAoZmJydlN0ci5sZW5ndGggPCA5KSB7XG4gICAgICAgIC8vIENvbXBsZXRlIHBhcnRpYWwgRkJSViB3aXRoIHJhbmRvbSBudW1iZXJzXG4gICAgICAgIGNvbnN0IHJlbWFpbmluZ0RpZ2l0cyA9IDkgLSBmYnJ2U3RyLmxlbmd0aFxuICAgICAgICBjb25zdCByYW5kb21QYXJ0ID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogTWF0aC5wb3coMTAsIHJlbWFpbmluZ0RpZ2l0cykpXG4gICAgICAgICAgLnRvU3RyaW5nKClcbiAgICAgICAgICAucGFkU3RhcnQocmVtYWluaW5nRGlnaXRzLCBcIjBcIilcbiAgICAgICAgZmJydiA9IGZicnZTdHIgKyByYW5kb21QYXJ0XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgZmJydl9wYXJ0ID0gZXh0cmEgPyBcIlwiIDogYDtGQk9QLzU7RkJSVi8ke2ZicnZ9YFxuICAgIGNvbnN0IGlhYm12ID0gTWF0aC5yYW5kb20oKSA8IDAuOSA/IFwiO0lBQk1WLzFcIiA6IFwiXCJcblxuICAgIHVzZXJBZ2VudCA9XG4gICAgICBgTW96aWxsYS81LjAgKGlQaG9uZTsgQ1BVIGlQaG9uZSBPUyAke2lvc1ZlcnNpb25VQX0gbGlrZSBNYWMgT1MgWCkgYCArXG4gICAgICBgQXBwbGVXZWJLaXQvJHtpb3NWZXJzaW9uLndlYmtpdF92ZXJzaW9ufSAoS0hUTUwsIGxpa2UgR2Vja28pIE1vYmlsZS8ke2lvc1ZlcnNpb24uYnVpbGRfbnVtYmVyfSBgICtcbiAgICAgIGBbRkJBTi9GQklPUztGQkFWLyR7YXBwVmVyc2lvbi52ZXJzaW9ufTtGQkJWLyR7YXBwVmVyc2lvbi5idWlsZF9udW1iZXJ9O0ZCRFYvJHtkZXZpY2UubW9kZWxfbmFtZX07RkJNRC9pUGhvbmU7RkJTTi9pT1M7YCArXG4gICAgICBgRkJTVi8ke2lvc1ZlcnNpb24udmVyc2lvbn07RkJTUy8ke2Zic3N9O0ZCSUQvcGhvbmU7RkJMQy8ke2xhbmd1YWdlfSR7ZXh0cmF9JHtmYnJ2X3BhcnR9JHtpYWJtdn1dYFxuICB9XG5cbiAgY29uc29sZS5sb2coXCJHZW5lcmF0ZWQgVXNlciBBZ2VudDpcIiwgdXNlckFnZW50KVxuICByZXR1cm4gdXNlckFnZW50XG59XG5cbi8vIEFjY2Vzc0tleSBlbnRpdHkgY2xhc3MgZm9yIGF1dGhlbnRpY2F0aW9uIHN5c3RlbVxuZXhwb3J0IGNsYXNzIEFjY2Vzc0tleSBleHRlbmRzIEJhc2VFbnRpdHkge1xuICBzdGF0aWMgdGFibGVOYW1lID0gXCJhY2Nlc3Nfa2V5c1wiXG5cbiAgLy8gR2VuZXJhdGUgYSByYW5kb20gYWNjZXNzIGtleVxuICBzdGF0aWMgZ2VuZXJhdGVSYW5kb21LZXkoKTogc3RyaW5nIHtcbiAgICBjb25zdCBjaGFycyA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSdcbiAgICBsZXQgcmVzdWx0ID0gJydcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDMyOyBpKyspIHtcbiAgICAgIHJlc3VsdCArPSBjaGFycy5jaGFyQXQoTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogY2hhcnMubGVuZ3RoKSlcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG5cbiAgLy8gQ3JlYXRlIGEgbmV3IGFjY2VzcyBrZXlcbiAgc3RhdGljIGFzeW5jIGNyZWF0ZUFjY2Vzc0tleShkYXRhOiB7XG4gICAgYWNjZXNzX2tleT86IHN0cmluZ1xuICAgIHVzZXJfbmFtZTogc3RyaW5nXG4gICAgdHlwZTogJ3VzZXInIHwgJ2FkbWluJ1xuICAgIGV4cGlyZXNfYXQ/OiBzdHJpbmdcbiAgICBpc19hY3RpdmU/OiBib29sZWFuXG4gIH0pIHtcbiAgICBpZiAoIWlzU3VwYWJhc2VBdmFpbGFibGUoKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU3VwYWJhc2Ugbm90IGF2YWlsYWJsZVwiKVxuICAgIH1cblxuICAgIGNvbnN0IGtleURhdGEgPSB7XG4gICAgICBhY2Nlc3Nfa2V5OiBkYXRhLmFjY2Vzc19rZXkgfHwgdGhpcy5nZW5lcmF0ZVJhbmRvbUtleSgpLFxuICAgICAgdXNlcl9uYW1lOiBkYXRhLnVzZXJfbmFtZSxcbiAgICAgIHR5cGU6IGRhdGEudHlwZSxcbiAgICAgIGV4cGlyZXNfYXQ6IGRhdGEuZXhwaXJlc19hdCB8fCBudWxsLFxuICAgICAgaXNfYWN0aXZlOiBkYXRhLmlzX2FjdGl2ZSAhPT0gdW5kZWZpbmVkID8gZGF0YS5pc19hY3RpdmUgOiB0cnVlLFxuICAgICAgY3JlYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgbGFzdF9sb2dpbjogbnVsbFxuICAgIH1cblxuICAgIGNvbnNvbGUubG9nKCdDcmVhdGluZyBhY2Nlc3Mga2V5OicsIGtleURhdGEpXG4gICAgXG4gICAgY29uc3QgeyBkYXRhOiByZXN1bHQsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZSFcbiAgICAgIC5mcm9tKHRoaXMudGFibGVOYW1lKVxuICAgICAgLmluc2VydChrZXlEYXRhKVxuICAgICAgLnNlbGVjdCgpXG4gICAgICAuc2luZ2xlKClcblxuICAgIGlmIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgY3JlYXRpbmcgYWNjZXNzIGtleTonLCBlcnJvcilcbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuICAgIFxuICAgIHJldHVybiByZXN1bHRcbiAgfVxuXG4gIC8vIFVwZGF0ZSBhY2Nlc3Mga2V5IChhZG1pbiBjYW4gbW9kaWZ5IGtleXMpXG4gIHN0YXRpYyBhc3luYyB1cGRhdGVBY2Nlc3NLZXkoaWQ6IHN0cmluZywgZGF0YToge1xuICAgIHVzZXJfbmFtZT86IHN0cmluZ1xuICAgIHR5cGU/OiAndXNlcicgfCAnYWRtaW4nXG4gICAgZXhwaXJlc19hdD86IHN0cmluZyB8IG51bGxcbiAgICBpc19hY3RpdmU/OiBib29sZWFuXG4gIH0pIHtcbiAgICByZXR1cm4gdGhpcy51cGRhdGUoaWQsIGRhdGEpXG4gIH1cblxuICAvLyBEZWxldGUgYWNjZXNzIGtleVxuICBzdGF0aWMgYXN5bmMgZGVsZXRlQWNjZXNzS2V5KGlkOiBzdHJpbmcpIHtcbiAgICByZXR1cm4gdGhpcy5kZWxldGUoaWQpXG4gIH1cblxuICAvLyBMaXN0IGFsbCBhY2Nlc3Mga2V5cyAoYWRtaW4gb25seSlcbiAgc3RhdGljIGFzeW5jIGxpc3RBbGxLZXlzKCkge1xuICAgIHJldHVybiB0aGlzLmxpc3QoJy1jcmVhdGVkX2F0JylcbiAgfVxuICBzdGF0aWMgYXN5bmMgYXV0aGVudGljYXRlKGFjY2Vzc0tleTogc3RyaW5nKSB7XG4gICAgaWYgKCFpc1N1cGFiYXNlQXZhaWxhYmxlKCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlN1cGFiYXNlIG5vdCBhdmFpbGFibGVcIilcbiAgICB9XG5cbiAgICBjb25zb2xlLmxvZyhcIkF1dGhlbnRpY2F0aW5nIHdpdGgga2V5OlwiLCBhY2Nlc3NLZXkpXG5cbiAgICBjb25zdCB7IGRhdGE6IHVzZXIsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZSFcbiAgICAgIC5mcm9tKHRoaXMudGFibGVOYW1lKVxuICAgICAgLnNlbGVjdChcIipcIilcbiAgICAgIC5lcShcImFjY2Vzc19rZXlcIiwgYWNjZXNzS2V5KVxuICAgICAgLnNpbmdsZSgpXG5cbiAgICBpZiAoZXJyb3IgfHwgIXVzZXIpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJBdXRoZW50aWNhdGlvbiBmYWlsZWQ6XCIsIGVycm9yKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBhY2Nlc3Mga2V5XCIpXG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgaWYga2V5IGlzIGFjdGl2ZVxuICAgIGlmICghdXNlci5pc19hY3RpdmUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkFjY2VzcyBrZXkgaXMgZGVhY3RpdmF0ZWRcIilcbiAgICB9XG5cbiAgICAvLyBDaGVjayBpZiBrZXkgaXMgZXhwaXJlZFxuICAgIGlmICh1c2VyLmV4cGlyZXNfYXQpIHtcbiAgICAgIGNvbnN0IGV4cGlyeURhdGUgPSBuZXcgRGF0ZSh1c2VyLmV4cGlyZXNfYXQpXG4gICAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpXG4gICAgICBpZiAobm93ID4gZXhwaXJ5RGF0ZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBY2Nlc3Mga2V5IGhhcyBleHBpcmVkXCIpXG4gICAgICB9XG4gICAgfVxuICAgIC8vIFVwZGF0ZSBsYXN0IGxvZ2luXG4gICAgYXdhaXQgdGhpcy51cGRhdGUodXNlci5pZCwgeyBsYXN0X2xvZ2luOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkgfSlcblxuICAgIGNvbnNvbGUubG9nKFwiQXV0aGVudGljYXRpb24gc3VjY2Vzc2Z1bDpcIiwgdXNlcilcbiAgICByZXR1cm4gdXNlclxuICB9XG5cbiAgLy8gR2V0IGN1cnJlbnQgYXV0aGVudGljYXRlZCB1c2VyIGZyb20gbG9jYWxTdG9yYWdlIHdpdGggc2Vzc2lvblN0b3JhZ2UgZmFsbGJhY2tcbiAgc3RhdGljIGdldEN1cnJlbnRVc2VyKCkge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSByZXR1cm4gbnVsbFxuXG4gICAgLy8gVHJ5IGxvY2FsU3RvcmFnZSBmaXJzdFxuICAgIGxldCBzdG9yZWRVc2VyID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oXCJhdXRoZW50aWNhdGVkX3VzZXJcIilcbiAgICBsZXQgc3RvcmFnZVR5cGUgPSBcImxvY2FsU3RvcmFnZVwiXG5cbiAgICAvLyBJZiBsb2NhbFN0b3JhZ2UgZmFpbHMgb3IgaXMgZW1wdHksIHRyeSBzZXNzaW9uU3RvcmFnZVxuICAgIGlmICghc3RvcmVkVXNlcikge1xuICAgICAgc3RvcmVkVXNlciA9IHNlc3Npb25TdG9yYWdlLmdldEl0ZW0oXCJhdXRoZW50aWNhdGVkX3VzZXJcIilcbiAgICAgIHN0b3JhZ2VUeXBlID0gXCJzZXNzaW9uU3RvcmFnZVwiXG4gICAgfVxuXG4gICAgaWYgKHN0b3JlZFVzZXIpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHVzZXIgPSBKU09OLnBhcnNlKHN0b3JlZFVzZXIpXG4gICAgICAgIGNvbnNvbGUubG9nKGBSZXRyaWV2ZWQgdXNlciBmcm9tICR7c3RvcmFnZVR5cGV9OmAsIHVzZXIpXG4gICAgICAgIHJldHVybiB1c2VyXG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGBGYWlsZWQgdG8gcGFyc2UgdXNlciBmcm9tICR7c3RvcmFnZVR5cGV9LCByZW1vdmluZzpgLCBlKVxuICAgICAgICAvLyBDbGVhbiB1cCBjb3JydXB0ZWQgZGF0YSBmcm9tIGJvdGggc3RvcmFnZXNcbiAgICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oXCJhdXRoZW50aWNhdGVkX3VzZXJcIilcbiAgICAgICAgc2Vzc2lvblN0b3JhZ2UucmVtb3ZlSXRlbShcImF1dGhlbnRpY2F0ZWRfdXNlclwiKVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnNvbGUubG9nKFwiTm8gdXNlciBmb3VuZCBpbiBlaXRoZXIgbG9jYWxTdG9yYWdlIG9yIHNlc3Npb25TdG9yYWdlXCIpXG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIHN0YXRpYyBhc3luYyB2YWxpZGF0ZUN1cnJlbnRVc2VyKCkge1xuICAgIGNvbnN0IGN1cnJlbnRVc2VyID0gdGhpcy5nZXRDdXJyZW50VXNlcigpXG4gICAgaWYgKCFjdXJyZW50VXNlcikgcmV0dXJuIG51bGxcblxuICAgIHRyeSB7XG4gICAgICAvLyBSZS1hdXRoZW50aWNhdGUgd2l0aCBkYXRhYmFzZSB0byBnZXQgZnJlc2ggZGF0YVxuICAgICAgY29uc3QgdmFsaWRhdGVkVXNlciA9IGF3YWl0IHRoaXMuYXV0aGVudGljYXRlKGN1cnJlbnRVc2VyLmFjY2Vzc19rZXkpXG4gICAgICB0aGlzLnNldEN1cnJlbnRVc2VyKHZhbGlkYXRlZFVzZXIpXG4gICAgICByZXR1cm4gdmFsaWRhdGVkVXNlclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAvLyBLZXkgaXMgaW52YWxpZCwgZGVsZXRlZCwgb3IgZXhwaXJlZFxuICAgICAgdGhpcy5sb2dvdXQoKVxuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG4gIH1cblxuICAvLyBTdG9yZSBhdXRoZW50aWNhdGVkIHVzZXJcbiAgc3RhdGljIHNldEN1cnJlbnRVc2VyKHVzZXI6IGFueSkge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShcImF1dGhlbnRpY2F0ZWRfdXNlclwiLCBKU09OLnN0cmluZ2lmeSh1c2VyKSlcbiAgICB9XG4gIH1cblxuICAvLyBMb2dvdXQgdXNlclxuICBzdGF0aWMgbG9nb3V0KCkge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShcImF1dGhlbnRpY2F0ZWRfdXNlclwiKVxuICAgICAgc2Vzc2lvblN0b3JhZ2UucmVtb3ZlSXRlbShcImF1dGhlbnRpY2F0ZWRfdXNlclwiKVxuICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSBcIi9sb2dpblwiXG4gICAgfVxuICB9XG5cbiAgc3RhdGljIGlzQWRtaW4odXNlcj86IGFueSkge1xuICAgIGNvbnN0IGN1cnJlbnRVc2VyID0gdXNlciB8fCB0aGlzLmdldEN1cnJlbnRVc2VyKClcbiAgICByZXR1cm4gY3VycmVudFVzZXI/LnR5cGUgPT09ICdhZG1pbicgLy8gT25seSBhZG1pbiB0eXBlIHVzZXJzIGFyZSBhZG1pbnNcbiAgfVxuXG4gIHN0YXRpYyBjYW5HZW5lcmF0ZSh1c2VyPzogYW55KSB7XG4gICAgY29uc3QgY3VycmVudFVzZXIgPSB1c2VyIHx8IHRoaXMuZ2V0Q3VycmVudFVzZXIoKVxuICAgIHJldHVybiBjdXJyZW50VXNlcj8udHlwZSA9PT0gJ3VzZXInIHx8IGN1cnJlbnRVc2VyPy50eXBlID09PSAnYWRtaW4nIC8vIEJvdGggdXNlciBhbmQgYWRtaW4gY2FuIGdlbmVyYXRlXG4gIH1cblxuICBzdGF0aWMgaXNVc2VyKHVzZXI/OiBhbnkpIHtcbiAgICBjb25zdCBjdXJyZW50VXNlciA9IHVzZXIgfHwgdGhpcy5nZXRDdXJyZW50VXNlcigpXG4gICAgcmV0dXJuIGN1cnJlbnRVc2VyPy50eXBlID09PSAndXNlcidcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgVXNlckdlbmVyYXRpb24gZXh0ZW5kcyBCYXNlRW50aXR5IHtcbiAgc3RhdGljIHRhYmxlTmFtZSA9IFwidXNlcl9nZW5lcmF0aW9uc1wiXG5cbiAgc3RhdGljIGFzeW5jIGNyZWF0ZUdlbmVyYXRpb24oYWNjZXNzS2V5OiBzdHJpbmcsIHVzZXJOYW1lOiBzdHJpbmcsIGdlbmVyYXRlZERhdGE6IGFueSwgcGxhdGZvcm06IHN0cmluZykge1xuICAgIGlmICghaXNTdXBhYmFzZUF2YWlsYWJsZSgpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTdXBhYmFzZSBub3QgYXZhaWxhYmxlXCIpXG4gICAgfVxuXG4gICAgY29uc3QgZ2VuZXJhdGlvbkRhdGEgPSB7XG4gICAgICBhY2Nlc3Nfa2V5OiBhY2Nlc3NLZXksXG4gICAgICB1c2VyX25hbWU6IHVzZXJOYW1lLFxuICAgICAgZ2VuZXJhdGVkX2RhdGE6IGdlbmVyYXRlZERhdGEsXG4gICAgICBwbGF0Zm9ybTogcGxhdGZvcm0sXG4gICAgICBjcmVhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgfVxuXG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuY3JlYXRlKGdlbmVyYXRpb25EYXRhKVxuICB9XG5cbiAgc3RhdGljIGFzeW5jIGdldFVzZXJIaXN0b3J5KGFjY2Vzc0tleTogc3RyaW5nLCBsaW1pdCA9IDUwKSB7XG4gICAgaWYgKCFpc1N1cGFiYXNlQXZhaWxhYmxlKCkpIHtcbiAgICAgIHJldHVybiBbXVxuICAgIH1cblxuICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlIVxuICAgICAgLmZyb20odGhpcy50YWJsZU5hbWUpXG4gICAgICAuc2VsZWN0KFwiKlwiKVxuICAgICAgLmVxKFwiYWNjZXNzX2tleVwiLCBhY2Nlc3NLZXkpXG4gICAgICAub3JkZXIoXCJjcmVhdGVkX2F0XCIsIHsgYXNjZW5kaW5nOiBmYWxzZSB9KVxuICAgICAgLmxpbWl0KGxpbWl0KVxuXG4gICAgaWYgKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgZmV0Y2hpbmcgdXNlciBoaXN0b3J5OlwiLCBlcnJvcilcbiAgICAgIHJldHVybiBbXVxuICAgIH1cblxuICAgIHJldHVybiBkYXRhIHx8IFtdXG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIEFkbWluTm90aWNlIGV4dGVuZHMgQmFzZUVudGl0eSB7XG4gIHN0YXRpYyB0YWJsZU5hbWUgPSBcImFkbWluX25vdGljZXNcIlxuXG4gIHN0YXRpYyBhc3luYyBnZXRBY3RpdmVOb3RpY2VzKHRhcmdldFVzZXI/OiBzdHJpbmcpIHtcbiAgICBpZiAoIWlzU3VwYWJhc2VBdmFpbGFibGUoKSkge1xuICAgICAgcmV0dXJuIFtdXG4gICAgfVxuXG4gICAgbGV0IHF1ZXJ5ID0gc3VwYWJhc2UhLmZyb20odGhpcy50YWJsZU5hbWUpLnNlbGVjdChcIipcIikuZXEoXCJpc19hY3RpdmVcIiwgdHJ1ZSlcblxuICAgIC8vIEdldCBub3RpY2VzIGZvciBzcGVjaWZpYyB1c2VyIG9yIGdsb2JhbCBub3RpY2VzXG4gICAgaWYgKHRhcmdldFVzZXIpIHtcbiAgICAgIHF1ZXJ5ID0gcXVlcnkub3IoYHRhcmdldF91c2VyLmVxLiR7dGFyZ2V0VXNlcn0sdGFyZ2V0X3VzZXIuaXMubnVsbGApXG4gICAgfSBlbHNlIHtcbiAgICAgIHF1ZXJ5ID0gcXVlcnkuaXMoXCJ0YXJnZXRfdXNlclwiLCBudWxsKVxuICAgIH1cblxuICAgIC8vIEZpbHRlciBvdXQgZXhwaXJlZCBub3RpY2VzXG4gICAgcXVlcnkgPSBxdWVyeS5vcihgZXhwaXJlc19hdC5pcy5udWxsLGV4cGlyZXNfYXQuZ3QuJHtuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCl9YClcblxuICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHF1ZXJ5Lm9yZGVyKFwiY3JlYXRlZF9hdFwiLCB7IGFzY2VuZGluZzogZmFsc2UgfSlcblxuICAgIGlmIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGZldGNoaW5nIG5vdGljZXM6XCIsIGVycm9yKVxuICAgICAgcmV0dXJuIFtdXG4gICAgfVxuXG4gICAgcmV0dXJuIGRhdGEgfHwgW11cbiAgfVxuXG4gIHN0YXRpYyBhc3luYyBjcmVhdGVOb3RpY2UodGl0bGU6IHN0cmluZywgbWVzc2FnZTogc3RyaW5nLCB0YXJnZXRVc2VyPzogc3RyaW5nLCBleHBpcmVzQXQ/OiBzdHJpbmcpIHtcbiAgICBjb25zdCBub3RpY2VEYXRhID0ge1xuICAgICAgdGl0bGUsXG4gICAgICBtZXNzYWdlLFxuICAgICAgdGFyZ2V0X3VzZXI6IHRhcmdldFVzZXIgfHwgbnVsbCxcbiAgICAgIGV4cGlyZXNfYXQ6IGV4cGlyZXNBdCB8fCBudWxsLFxuICAgICAgaXNfYWN0aXZlOiB0cnVlLFxuICAgICAgY3JlYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgIH1cblxuICAgIHJldHVybiBhd2FpdCB0aGlzLmNyZWF0ZShub3RpY2VEYXRhKVxuICB9XG59XG4iXSwibmFtZXMiOlsiY3JlYXRlQ2xpZW50Iiwic3VwYWJhc2VVcmwiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfU1VQQUJBU0VfVVJMIiwic3VwYWJhc2VBbm9uS2V5IiwiTkVYVF9QVUJMSUNfU1VQQUJBU0VfQU5PTl9LRVkiLCJzdXBhYmFzZSIsImF1dGgiLCJhdXRvUmVmcmVzaFRva2VuIiwicGVyc2lzdFNlc3Npb24iLCJkZXRlY3RTZXNzaW9uSW5VcmwiLCJpc1N1cGFiYXNlQXZhaWxhYmxlIiwiQmFzZUVudGl0eSIsImxpc3QiLCJvcmRlckJ5IiwiY29uc29sZSIsIndhcm4iLCJ0YWJsZU5hbWUiLCJsb2ciLCJkYXRhIiwiZXJyb3IiLCJmcm9tIiwic2VsZWN0Iiwib3JkZXIiLCJzdGFydHNXaXRoIiwic2xpY2UiLCJhc2NlbmRpbmciLCJjcmVhdGUiLCJFcnJvciIsInJlc3VsdCIsImluc2VydCIsInNpbmdsZSIsInVwZGF0ZSIsImlkIiwiZXEiLCJkZWxldGUiLCJmaWx0ZXIiLCJmaWx0ZXJzIiwicXVlcnkiLCJPYmplY3QiLCJlbnRyaWVzIiwiZm9yRWFjaCIsImtleSIsInZhbHVlIiwiRGV2aWNlTW9kZWwiLCJJT1NWZXJzaW9uIiwiQXBwVmVyc2lvbiIsIkNvbmZpZ3VyYXRpb24iLCJHZW5lcmF0aW9uSGlzdG9yeSIsIkJsYWNrbGlzdGVkVXNlckFnZW50IiwiQW5kcm9pZERldmljZU1vZGVsIiwiQW5kcm9pZEJ1aWxkTnVtYmVyIiwiQW5kcm9pZEFwcFZlcnNpb24iLCJJbnN0YWdyYW1EZXZpY2VNb2RlbCIsIkluc3RhZ3JhbVZlcnNpb24iLCJDaHJvbWVWZXJzaW9uIiwiUmVzb2x1dGlvbkRwaSIsIlVzZXIiLCJtZSIsInN0b3JlZFVzZXIiLCJsb2NhbFN0b3JhZ2UiLCJnZXRJdGVtIiwiSlNPTiIsInBhcnNlIiwiZSIsInJlbW92ZUl0ZW0iLCJsb2dpbldpdGhFbWFpbCIsImVtYWlsIiwiZXhpc3RpbmdVc2VyIiwic2VsZWN0RXJyb3IiLCJzZXRJdGVtIiwic3RyaW5naWZ5IiwiY29kZSIsIm5ld1VzZXJEYXRhIiwiaXNfYXBwcm92ZWQiLCJuZXdVc2VyIiwiaW5zZXJ0RXJyb3IiLCJtZXNzYWdlIiwibG9naW4iLCJwcm9tcHQiLCJ0cmltIiwidXNlciIsImFsZXJ0Iiwid2luZG93IiwibG9jYXRpb24iLCJyZWxvYWQiLCJsb2dvdXQiLCJnZXRDdXJyZW50VXNlciIsImdldFJhbmRvbUVsZW1lbnQiLCJhcnIiLCJNYXRoIiwiZmxvb3IiLCJyYW5kb20iLCJsZW5ndGgiLCJnZW5lcmF0ZVVzZXJBZ2VudCIsImRldmljZVNjYWxpbmciLCJpb3NWZXJzaW9uVUEiLCJpb3NWZXJzaW9uIiwid2Via2l0X3ZlcnNpb24iLCJidWlsZF9udW1iZXIiLCJ2ZXJzaW9uIiwiYXBwVmVyc2lvbiIsImZicnYiLCJkZXZpY2UiLCJtb2RlbF9uYW1lIiwibGFuZ3VhZ2UiLCJ1c2VyQWdlbnQiLCJmYnNzIiwibWFwIiwicyIsInJlcGxhY2UiLCJleHRyYSIsImZicnZTdHIiLCJ0b1N0cmluZyIsInJlbWFpbmluZ0RpZ2l0cyIsInJhbmRvbVBhcnQiLCJwb3ciLCJwYWRTdGFydCIsImZicnZfcGFydCIsImlhYm12IiwiQWNjZXNzS2V5IiwiZ2VuZXJhdGVSYW5kb21LZXkiLCJjaGFycyIsImkiLCJjaGFyQXQiLCJjcmVhdGVBY2Nlc3NLZXkiLCJrZXlEYXRhIiwiYWNjZXNzX2tleSIsInVzZXJfbmFtZSIsInR5cGUiLCJleHBpcmVzX2F0IiwiaXNfYWN0aXZlIiwidW5kZWZpbmVkIiwiY3JlYXRlZF9hdCIsIkRhdGUiLCJ0b0lTT1N0cmluZyIsImxhc3RfbG9naW4iLCJ1cGRhdGVBY2Nlc3NLZXkiLCJkZWxldGVBY2Nlc3NLZXkiLCJsaXN0QWxsS2V5cyIsImF1dGhlbnRpY2F0ZSIsImFjY2Vzc0tleSIsImV4cGlyeURhdGUiLCJub3ciLCJzdG9yYWdlVHlwZSIsInNlc3Npb25TdG9yYWdlIiwidmFsaWRhdGVDdXJyZW50VXNlciIsImN1cnJlbnRVc2VyIiwidmFsaWRhdGVkVXNlciIsInNldEN1cnJlbnRVc2VyIiwiaHJlZiIsImlzQWRtaW4iLCJjYW5HZW5lcmF0ZSIsImlzVXNlciIsIlVzZXJHZW5lcmF0aW9uIiwiY3JlYXRlR2VuZXJhdGlvbiIsInVzZXJOYW1lIiwiZ2VuZXJhdGVkRGF0YSIsInBsYXRmb3JtIiwiZ2VuZXJhdGlvbkRhdGEiLCJnZW5lcmF0ZWRfZGF0YSIsImdldFVzZXJIaXN0b3J5IiwibGltaXQiLCJBZG1pbk5vdGljZSIsImdldEFjdGl2ZU5vdGljZXMiLCJ0YXJnZXRVc2VyIiwib3IiLCJpcyIsImNyZWF0ZU5vdGljZSIsInRpdGxlIiwiZXhwaXJlc0F0Iiwibm90aWNlRGF0YSIsInRhcmdldF91c2VyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///3023\n"));

/***/ }),

/***/ 3622:
/*!**********************!*\
  !*** ./lib/utils.ts ***!
  \**********************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   cn: function() { return /* binding */ cn; }\n/* harmony export */ });\n/* harmony import */ var clsx__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! clsx */ 8099);\n/* harmony import */ var tailwind_merge__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tailwind-merge */ 8543);\n\n\nfunction cn() {\n    for(var _len = arguments.length, inputs = new Array(_len), _key = 0; _key < _len; _key++){\n        inputs[_key] = arguments[_key];\n    }\n    return (0,tailwind_merge__WEBPACK_IMPORTED_MODULE_1__.twMerge)((0,clsx__WEBPACK_IMPORTED_MODULE_0__.clsx)(inputs));\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzYyMi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBNEM7QUFDSjtBQUVqQyxTQUFTRTtJQUFHO1FBQUdDLE9BQUgsdUJBQXVCOztJQUN4QyxPQUFPRix1REFBT0EsQ0FBQ0QsMENBQUlBLENBQUNHO0FBQ3RCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2xpYi91dGlscy50cz9mNzQ1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHR5cGUgQ2xhc3NWYWx1ZSwgY2xzeCB9IGZyb20gXCJjbHN4XCJcbmltcG9ydCB7IHR3TWVyZ2UgfSBmcm9tIFwidGFpbHdpbmQtbWVyZ2VcIlxuXG5leHBvcnQgZnVuY3Rpb24gY24oLi4uaW5wdXRzOiBDbGFzc1ZhbHVlW10pIHtcbiAgcmV0dXJuIHR3TWVyZ2UoY2xzeChpbnB1dHMpKVxufVxuIl0sIm5hbWVzIjpbImNsc3giLCJ0d01lcmdlIiwiY24iLCJpbnB1dHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///3622\n"));

/***/ })

}]);